# 메모이제이션 기법(feat. memo, useMemo, useCallback)

리액트에서 제공하는 API중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

- 메모이제이션 기법은 언제 하용하는 것이 좋을까?
- 렌더링이 자주 일어나는 컴포넌트?
- 렌더링이 자주 일어나는 컴포넌트를 어떻게 알 수 있을까?
- 코드를 꼼꼼히 읽어서 렌더링이 일어날 것 같은 영역에 모조리 추가할까?
- 아니면 의존성 배열이 생략된 useEffect를 모든 컴포넌트에 추가해서 실제로 렌더링이 돌아가는지 확인해 봐야 할까?
- 무거운 연산의 기준은 무엇일까?
- 실제로 코드를 작성할 때 함수의 실행 속도나 컴포넌트 렌더링 속도를 매번 계산하는 것이 좋은 걸까?
  계산한다면 그 기준은 무엇일까?
- 이렇게 최적화에 대해 매번 고민할 바엔 그냥 모든 컴포넌트를 메모이제이션해 버리는 게 낫지 않을까?
- 함수 결과도 다 메모이제이션할까?
- 렌더링 비용과 메모이제이션 비용 중 어떤 게 더 비싼걸까?

모던 리액트 딥다이브에서는 위의 질문들에 대해 각 진영의 주장을 살펴보고 현명하고 효율적으로 리액트에서 메모이제이션하는 법에 대해 다루고 있다.

## 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자.

메모이제이션도 비용이 드는 작업으로 최적화에 대한 비용을 지불 할 때는 항상 신중해야 한다.

```jsx
function sum(a, b) {
  return a + b;
}
```

위와 같은 대부분의 가벼운 작업 자체는 메모이제이션해서 자바스크립트 메모리 어딘가에 두었다가 그것을 다시 꺼내오는 것보다는 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수도 잇다.

메모이제이션에도 비용이 든다. 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다. 과연 이 비용이 리렌더링 비용보다 저렴하다고 할 수 있을까? 항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화(premature memoization)는 항상 경계해야한다.

미리 개발자가 렌더링이 많이 될 것 같은 부분을 예측해 메모이제이션하는, 이름바 섣부른 최적화는 옳지 못한 행동이다. 일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다.

## 주장 2: 렌저링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다. 섣부른 최적화인지 여부와는 관계없이, 만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 분명히 있다.

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법

- memo를 일단 그냥 다 적용하는 방법

렌더링 비용이 저렴하거나 사실 별로 렌더링이 안 되는 컴포넌트에 memo를 썼을 때 역으로 지불해야 하는 비용을 생각해보자. 잘못된 memo로 지불해야 하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다. 메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 이전 결과물을 사용해야 한다.

리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다. 그것이 기본적인 리액트의 재조정 알고리즘이기 때문이다. 즉, 어차피 리액트이 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다. 따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교 뿐인 것이다.

### memo를 하지 않았을 때 발생할 수 있는 문제

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

### useMemo와 useCallback

useMemo와 useCallback을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다. 그렇다면 이 또한 마찬가지로 무조건 메모이제이션하는 방법을 먼저 고민해 볼 필요가 있다.

리렌더링이 발생할 때 메모이제이션과 같은 별도 조치가 없다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다. 이 달라진 참조에 대한 값을 어디서든 쓰지 않는다면 큰 문제가 되지 않을 수 있지만 이 값이 useEffect와 같은 의존성 배열에 쓰이면 어떻게 될까?

```tsx
function useMath(number: number) {
  const [double, setDouble] = useState(0)
  const [triple, setTriple] = useState(0)

  useEffect(() => {
    setDouble(number * 2)
    setTriple(number * 3)
  }, [number])

  return { double, triple }
}

export default function App() {
  const [counter, setCounter] = useState(0)
  const value = useMath(10)

  useEffect(() => {
    console.log(value.double, value.triple)
  }, [value]) // 값이 실제로 변한 건 없는데 계속해서 console.log가 출력된다.

  function handleClick() {
    setCount((prev) => prev + 1)
  }

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}+</button>
    </>
  )
}
```

위 useMath훅을 살펴보자. 이 훅은 인수로 넘겨주는 값이 변하지 않는 이상 같은 값을 가지고 있어야 하는데, 실제로 handleClick으로 렌더링을 강제로 일으켜 보면 console.log가 출력되는 것을 볼 수 있다. 함수의 컴포넌트인 App이 호출되면서 useMath가 계속해서 호출되고, 객체 내부의 값 같지만 참조가 변경되기 때문이다.

```tsx
function useMath(number: number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return useMemo(() => ({ double, triple }), [double, triple]);
}
```

useMath의 반환값을 useMemo로 감싼다면 값이 변경되지 않는 한 같은 결과물을 가질 수 있고, 그 덕분에 사용하는 쪽에서도 참조의 투명성을 유지할 수 있게 된다. 즉, 메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다.

> 정리하자면, 메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있다. 이것이 비록 섣부른 초기화라 할지라도 했을 떄 누릴 수 있는 이점, 그리고 이를 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

## 결론 및 정리

- 초보자라면

  - 섣부른 메모이제이션 지양 > 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보기
  - 실제로 크롬 메모리 프로파일러로 분석하면서 state나 props의 변화에 따라 크롬 내부에서 어떤 일이 일어나는지 확인할 수 있는 방법으로 실제 웹 애플리케이션 성능에 어떠한 영향을 미치는지 꼼꼼하게 살펴보자.

- 실무자라면
  - 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장
  - useCallback의 경우는 대부분 다른 컴포넌트의 props로 넘어가는 경우가 많을 것이다. 이 props로 넘어갔을 때 참조 투명성을 유지하기 위해서는 useCallback을 사용하는 것이 좋다
  - useMemo 또한 마찬가지다. props로 넘어가거나 이를 활용할 여지가 있다면 사용하는 것이 좋다.
