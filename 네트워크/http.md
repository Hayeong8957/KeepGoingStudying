# HTTP가 뭐죠?

HTTP(HyperText Transfer Protocol), 텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.
이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다.

- 무상태 프로토콜이며, 클라-서버 간 어떠한 상태나 데이터를 유지하지 않음 -> 상태 유지 위한 노력으로 cookie와 session을 사용한다.
- 일반적으로 안정적인 TCP/IP 레이어를 기반으로 사용하는 응용 프로토콜이다.

# HTTP의 상태 코드를 읊어보아라.
1. 100 ~ 199 : 정보성 상태 코드

2. 200 ~ 299 : 성공 상태 코드

3. 300 ~ 399 : 리다이렉션 상태 코드

4. 400 ~ 499 : 클라이언트 에러 상태 코드

5. 500 ~ 599 : 서버 에러 상태 코드

이외에 각 범주 내 번호들에 대한 설명은 [여기에서](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)

# HTTP와 HTTPS의 차이점
HTTP통신에서 브라우저와 서버는 데이터를 일반 텍스트로 교환한다. HTTP는 데이터를 암호화하지 않고 전송하기 때문에 제 3자가 데이터를 가로채고 읽을 수 있다.
보안을 강화하기 위해 HTTP는 HTTPS로 확장 되었다.
HTTPS에서는 브라우저와 서버가 데이터를 전송하기 전에 안전하고 암호화된 연결을 생성한다.
HTTPS는 모든 요청 및 응답을 SSL(Secure Socket Layer) 및 TLS(Transport Layer Security)프로토콜에 따라 암호화한다.
그래서 HTTPS를 사용하면 카드 정보나 비밀번호와 같은 민감한 정보를 보호할 수 있다.

# HTTPS의 동작 원리
## 대칭키
- 암호화, 복호화 할 때 서로 키가 같은 경우
- (장) 매우 빠르고 효율적. 대량의 데이터 처리시 유리
- (단) 키를 공유해야 하는 문제점. 클라와 서버가 동일 키를 사용해야 하기 때문에 키가 전송되는 동안 탈취 위험 존재. 

## 비대칭키(공개키)
- 암호화, 복호화 할 때 서로 키가 다른 경우
- (장) 공개키 노출되어도 개인키로만 복호화 가능하므로 안전 
- (단) 연산시간 길어 서버의 성능에 영향을 줌

## HTTPS에서의 혼합 사용
HTTPS는 이런 단점을 보완하기 위해 대칭키와 비대칭키 암호화를 혼합하여 사용한다.
이를 키 교환(Key Exchange)방식이라고 한다.
1. 클라이언트 요청 : 클라이언트가 서버에 접속 요청을 보낸다.
2. 서버 공개키 전달 : 서버는 클라이언트에게 자신의 공개키를 보낸다.
3. 세션 키 생성 및 암호화 : 클라이언트는 세션 키(대칭키)를 생성한 후, 서버의 공개키로 이 세션키를 암호화하여 서버에 보낸다.
4. 세션 키 복호화 : 서버는 자신의 개인키로 클라이언트가 보낸 세션 키를 복호화한다.
5. 대칭키 사용 : 이후 클라이언트와 서버는 이 세션키를 사용하여 대칭키 암호화 방식으로 데이터를 주고받는다.

## TCP 3-way 핸드셰이크
핸드셰이크는 악수를 의미, 통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름.

1) Client는 Server에게 접속요청을 위한 메시지(SYN)을 보낸다. 이때 19991115같은 별 의미없는 난수를 SEQ넘버로 같이 실어서 보낸다. 이제 Client는 SYN_SENT상태가 된다.

2) Server는 Client에게 SYN요청을 받은 다음, 연결을 수락(ACK)합니다. 이를 합쳐서 SYN+ACK라고 표현하기도 한다. 이때 클라이언트가 보내준 SEQ넘버에 딱 1을 더한 값과 서버 측에서도 20001115같은 의미없는 난수를 ACK넘버로 또 보내준다. 이제 서버는 SYN_RECEIVED상태가 된다.

3) Client는 Server에게 접속 수락 확인(SYN)을 보낸다. 이때 서버측에서 넘겨준 ACK넘버에 또 1을 더해서 같이 보내준다. 이제 TCP연결이 성립되었으며, 서버는 ESTABLISHED상태가 된다.

## SSL 핸드 셰이크 과정
1.  클라이언트) 클라이언트가 먼저 서버에 접속해서 말을 겁니다.(Client Hello)
내가 브라우저 주소창에서 naver.com 입력하면 내 브라우저는 네이버 웹 서버에 접속 시도합니다. HTTP는 TCP의 일종이니, TCP 연결을 위한 3-Way Handshake를 수행한 브라우저는 네이버가 HTTPS를 사용하는 것을 알게 된 브라우저는 다음 정보를 Client Hello 단계에서 보냅니다.

> - 브라우저가 사용하는 SSL 혹은 TLS 버전 정보
> - 브라우저가 지원하는 암호화 방식 모음(cipher suite)
> - 브라우저가 순간적으로 생성한 임의의 난수(숫자)
> - 만약 이전에 SSL 핸드 셰이크가 완료된 상태라면, 그때 생성된 세션 아이디(Session ID)
> - 기타 확장 정보(extension)

cipher suite 란, 보안의 궁극적 목표를 달성하기 위해 사용하는 방식을 패키지의 형태로 묶어놓은 것을 의미합니다. 여기서 보안의 목표란 다음과 같습니다.

> - 안전한 키 교환
> - 전달 대상 인증
> - 암호화 알고리즘
> - 메시지 무결성 확인 알고리즘

2. 서버) 서버 또한 위의 인사에 응답하면서, 다음 정보를 클라이언트에 제공합니다.(Sever Hello)

> - 브라우저의 암호화 방식 정보 중에서, 서버가 지원하고 선택한 암호화 방식(cipher sutie)
> - 서버의 공개키가 담긴 SSL 인증서. 인증서는 CA의 비밀키로 암호화되어 발급된 상태입니다.
> - 서버가 순간적으로 생성한 임의의 난수(숫자)
> - 클라이언트 인증서 요청(선택 사항)

3. 클라이언트) 브라우저는 서버의 SSL 인증서가 믿을만한지 확인합니다.
대부분 브라우저에는 공신력 있는 CA들의 정보와 CA가 만든 공개키가 이미 설치되어 있습니다. 서버가 보낸 SSL 인증서가 정말 CA가 만든 것인지를 확인하기 위해 내장된 CA 공개키로 암호화된 인증서를 복호화해봅니다. 정상적으로 복호화가 되었다면 CA가 발급한 것이 증명되는 셈입니다. 만약 등록된 CA가 아니거나, 등록된 CA가 만든 인증서처럼 꾸몄다면 이 과정에서 발각이 되며 브라우저 경고를 보냅니다.

4. 클라이언트) 브라우저는 자신이 생성한 난수와 서버의 난수를 사용하여 premaster secret을 만듭니다.
웹 서버 인증서에 딸려온 웹 사이트의 공개키로 이것을 암호화하여 서버로 전송합니다. 서버 인증서에 공개키가 같이 딸려오는 부분이 이해가 어려우신 분들은 아래 디지털 인증서의 원리에 대한 글을 한번 보세요.

5. 서버) 서버는 사이트의 비밀키로, 브라우저가 보낸 premaster secret 값을 복호화합니다.
복호화 한 값을 master secret 값으로 저장합니다. 이것을 사용하여 방금 브라우저와 만들어진 연결에 고유한 값을 부여하기 위한 session key를 생성합니다. 세션 키는 대칭키 암호화에 사용할 키입니다. 이것으로 브라우저와 서버 사이에 주고받는 데이터를 암호화하고 복호화합니다.

6. 서버/클라이언트) SSL handshake를 종료하고, 드디어 HTTPS 통신을 시작합니다.
브라우저와 서버는 SSL handshake가 정상적으로 완료되었고, 이제는 웹상에서 데이터를 세션 카를 사용하여 암호화/복호화하며 HTTPS 프로토콜을 통해 주고받을 수 있습니다. HTTPS 통신이 완료되는 시점에서 서로에게 공유된 세션 카를 폐기합니다. 만약 세션이 여전히 유지되고 있다면 브라우저는 SSL handshake 요청이 아닌 세션 ID만 서버에게 알려주면 됩니다. 이 부분은 ①에서 언급되었습니다.

# 클라이언트가 접속한 서버의 인증서가 유효한지 확인은 어떻게 하는가?
1) 먼저 서버는 SSL인증서가 필요하기 때문에 인증기관으로부터 인증서를 발급받기 위해 서버의 공개키와 서버 정보를 전달한다.
2) 인증기관에서는 전달받은 데이터를 인증기관의 개인키로 서명을 한다.
서명한 이 정보가 서버의 인증서가 된다. 
3) 서버는 인증기관으로부터 전달받은 인증서를 서버에 저장해둔다.
4) 인증기관들은 브라우저에 인증기관의 공개키를 제공한다. 
5) 클라이언트가 서버에 접속을 하기전 브라우저는 이미 주요인증기관의 리스트/공개키를 보유하고 있다. 클라이언트가 서버에 접속요청시 서버는 서버의 인증서를 클라이언트에게 전달하고 클라리언트에서는 전달받은 인증서를 보유하고 있던 인증기관의 공개키로 복호화해서 검증을 한다.
6) 이후는 SSL핸드셰이크를 하고 통신을 한다.